## ðŸ“ 953. Verifying an Alien Dictionary  
In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different `order`. The `order` of the alphabet is some permutation of lowercase letters.  
Given a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographically in this alien language.  
     
  
#### Example 1:  

```
Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.

```
#### Example 2:  

```
Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.

```
#### Example 3:  

```
Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
Output: false
Explanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > 'âˆ…', where 'âˆ…' is defined as the blank character which is less than any other character (More info).

```
  
#### Constraints:  
+ `1 <= words.length <= 100`  
+ `1 <= words[i].length <= 20`  
+ `order.length == 26`  
+ All characters in `words[i]` and `order` are English lowercase letters.  
  
## ðŸ“ Solution 
```php  
classÂ SolutionÂ {  
  
Â Â Â Â /**  
Â Â Â Â Â *Â @paramÂ String[]Â $words  
Â Â Â Â Â *Â @paramÂ StringÂ $order  
Â Â Â Â Â *Â @returnÂ Boolean  
Â Â Â Â Â */  
Â Â Â Â functionÂ isAlienSorted($words,Â $order)Â {  
Â Â Â Â Â Â Â Â $resultÂ =Â true;  
Â Â Â Â Â Â Â Â   
Â Â Â Â Â Â Â Â $abcLengthÂ =Â strlen($order);  
Â Â Â Â Â Â Â Â $abcOrderMapÂ =Â [];  
Â Â Â Â Â Â Â Â forÂ ($iÂ =Â 0;Â $iÂ <Â $abcLength;Â $i++)Â {  
Â Â Â Â Â Â Â Â Â Â Â Â $abcOrderMap[$order[$i]]Â =Â $i;  
Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â   
Â Â Â Â Â Â Â Â foreachÂ ($wordsÂ asÂ $indexÂ =>Â $word)Â {  
Â Â Â Â Â Â Â Â Â Â Â Â $nextIndexÂ =Â $indexÂ +Â 1;  
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (!isset($words[$nextIndex]))Â {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;  
Â Â Â Â Â Â Â Â Â Â Â Â }  
  
Â Â Â Â Â Â Â Â Â Â Â Â $wordLengthÂ =Â strlen($word);  
Â Â Â Â Â Â Â Â Â Â Â Â forÂ ($iÂ =Â 0;Â $iÂ <Â $wordLength;Â $i++)Â {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ (!isset($words[$nextIndex][$i])  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ||Â $abcOrderMap[$word[$i]]Â >Â $abcOrderMap[$words[$nextIndex][$i]]  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â )Â {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â returnÂ false;  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }Â elseÂ ifÂ ($abcOrderMap[$word[$i]]Â ===Â $abcOrderMap[$words[$nextIndex][$i]])Â {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue;  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }Â elseÂ {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break;  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â Â Â Â Â   
Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â   
Â Â Â Â Â Â Â Â returnÂ $result;  
Â Â Â Â }  
Â Â   
}  
```  
