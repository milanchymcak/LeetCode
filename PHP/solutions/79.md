## ğŸ“ 79. Word Search  
Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.  
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.  
     
  
#### Example 1:  
![79. Word Search](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
Output: true

```
#### Example 2:  
![79. Word Search](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
Output: true

```
#### Example 3:  
![79. Word Search](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
Input: board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
Output: false

```
  
#### Constraints:  
+ `m == board.length`  
+ `n = board[i].length`  
+ `1 <= m, n <= 6`  
+ `1 <= word.length <= 15`  
+ `board` and `word` consists of only lowercase and uppercase English letters.  
  
## ğŸ“ Solution 
```php  
classÂ SolutionÂ {  
  
Â Â Â Â /**  
Â Â Â Â Â *Â Directions  
Â Â Â Â Â *  
Â Â Â Â Â *Â @varÂ array  
Â Â Â Â Â */  
Â Â Â Â protectedÂ arrayÂ $directionsÂ =Â [  
Â Â Â Â Â Â Â Â [1,Â 0],  
Â Â Â Â Â Â Â Â [-1,Â 0],  
Â Â Â Â Â Â Â Â [0,Â 1],  
Â Â Â Â Â Â Â Â [0,Â -1],  
Â Â Â Â ];  
  
Â Â Â Â /**  
Â Â Â Â Â *Â TargetÂ Word  
Â Â Â Â Â *  
Â Â Â Â Â *Â @varÂ string  
Â Â Â Â Â */  
Â Â Â Â protectedÂ stringÂ $word;  
  
Â Â Â Â /**  
Â Â Â Â Â *Â TargetÂ WordÂ Length  
Â Â Â Â Â *  
Â Â Â Â Â *Â @varÂ integer  
Â Â Â Â Â */  
Â Â Â Â protectedÂ intÂ $wordLen;  
  
Â Â Â Â /**  
Â Â Â Â Â *Â Board  
Â Â Â Â Â *  
Â Â Â Â Â *Â @varÂ array  
Â Â Â Â Â */  
Â Â Â Â protectedÂ arrayÂ $board;  
  
Â Â Â Â /**  
Â Â Â Â Â *Â @paramÂ string[][]Â $board  
Â Â Â Â Â *Â @paramÂ stringÂ Â Â Â Â $word  
Â Â Â Â Â *  
Â Â Â Â Â *Â @returnÂ bool  
Â Â Â Â Â */  
Â Â Â Â publicÂ functionÂ exist(Â $board,Â $wordÂ )Â {  
  
Â Â Â Â Â Â Â Â $this->boardÂ =Â $board;  
Â Â Â Â Â Â Â Â $this->wordÂ =Â $word;  
Â Â Â Â Â Â Â Â $this->wordLenÂ =Â strlen($word);  
  
Â Â Â Â Â Â Â Â //Â LoopÂ row**column  
Â Â Â Â Â Â Â Â forÂ (Â $rowÂ =Â 0;Â $rowÂ <Â count($this->board);Â $row++Â )Â {  
Â Â Â Â Â Â Â Â Â Â Â Â forÂ (Â $colÂ =Â 0;Â $colÂ <Â count($this->board[$row]);Â $col++Â )Â {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ifÂ ($this->board[$row][$col]Â ===Â $word[0]Â &&Â $this->find($row,Â $col,Â 0))Â {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â returnÂ true;  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â }  
  
Â Â Â Â Â Â Â Â returnÂ false;  
Â Â Â Â }  
  
Â Â Â Â /**  
Â Â Â Â Â *Â FindÂ theÂ way  
Â Â Â Â Â *  
Â Â Â Â Â *Â @paramÂ integerÂ $row  
Â Â Â Â Â *Â @paramÂ integerÂ $col  
Â Â Â Â Â *Â @paramÂ integerÂ $index  
Â Â Â Â Â *Â @returnÂ boolean  
Â Â Â Â Â */  
Â Â Â Â protectedÂ functionÂ find(intÂ $row,Â intÂ $col,Â intÂ $index):Â boolÂ {  
  
Â Â Â Â Â Â Â Â $resÂ =Â false;  
Â Â Â Â Â Â Â Â ifÂ ($this->wordLenÂ ===Â $index)Â returnÂ true;  
Â Â Â Â Â Â Â Â ifÂ ($rowÂ >=Â count($this->board))Â returnÂ false;  
Â Â Â Â Â Â Â Â ifÂ ($colÂ >=Â count($this->board[0]))Â returnÂ false;  
Â Â Â Â Â Â Â Â ifÂ ($this->board[$row][$col]Â !==Â $this->word[$index])Â returnÂ false;  
  
Â Â Â Â Â Â Â Â $this->board[$row][$col]Â =Â 0;  
  
Â Â Â Â Â Â Â Â foreach($this->directionsÂ asÂ [$x,Â $y])Â {  
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ ($this->find($rowÂ +Â $x,Â $colÂ +Â $y,Â $indexÂ +Â 1))Â {  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â $resÂ =Â true;  
Â Â Â Â Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â }  
  
Â Â Â Â Â Â Â Â $this->board[$row][$col]Â =Â $this->word[$index];  
  
Â Â Â Â Â Â Â Â returnÂ $res;  
Â Â Â Â }  
}  
```  
